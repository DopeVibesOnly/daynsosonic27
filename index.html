<html>

<head>
  <base href="https://clickergame.example.com/v5">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>—Å–∏–≥–º–∞ –∫–ª–∏–∫–µ—Ä</title>
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background-color: #f0f0f0;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #game-area {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    }

    .coin {
      position: absolute;
      width: 50px;
      height: 50px;
      cursor: pointer;
      transition: transform 0.3s ease-out;
      z-index: 1;
    }

    .coin:hover {
      transform: scale(1.1);
    }

    #score {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 28px;
      font-weight: bold;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px 20px;
      border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      color: #2c3e50;
    }

    #menu-button {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 24px;
      padding: 12px 24px;
      background-color: #8e44ad;
      background-image: linear-gradient(45deg, #8e44ad, #3498db);
      color: white;
      border: none;
      cursor: pointer;
      z-index: 10;
      border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }

    #menu-button:hover {
      background-image: linear-gradient(45deg, #7f3fbf, #2980b9);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    #mini-game-button {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 24px;
      padding: 12px 24px;
      background-color: #e67e22;
      background-image: linear-gradient(45deg, #e67e22, #d35400);
      color: white;
      border: none;
      cursor: pointer;
      z-index: 10;
      border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }

    #mini-game-button:hover {
      background-image: linear-gradient(45deg, #cf711f, #c0392b);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    #upgrades-menu {
      display: none;
      position: absolute;
      top: 80px;
      left: 20px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 25px;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      max-width: 350px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 5;
      transition: all 0.3s ease;
    }

    .upgrade-section {
      margin-bottom: 25px;
      border-bottom: 2px solid #e0e0e0;
      padding-bottom: 15px;
    }

    .upgrade-section h2 {
      margin-top: 0;
      color: #2c3e50;
      font-size: 24px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .upgrade-item {
      margin-bottom: 20px;
      padding: 20px;
      background-color: #f9f9f9;
      border-radius: 15px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      z-index: 15;
    }

    .upgrade-item:hover {
      background-color: #f0f0f0;
      transform: translateY(-3px);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
    }

    .upgrade-item h3 {
      margin-top: 0;
      color: #34495e;
      font-size: 20px;
    }

    .upgrade-item p {
      font-size: 16px;
      margin-bottom: 10px;
      color: #7f8c8d;
    }

    .upgrade-item button {
      background-color: #2ecc71;
      color: white;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 16px;
      border-radius: 25px;
      transition: all 0.3s ease;
      width: 100%;
    }

    .upgrade-item button:hover {
      background-color: #27ae60;
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    }

    .upgrade-item button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    @keyframes confetti {
      0% {
        transform: translateY(0) rotate(0deg);
        opacity: 1;
      }

      100% {
        transform: translateY(1000px) rotate(720deg);
        opacity: 0;
      }
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #f0f;
      opacity: 0;
      pointer-events: none;
    }

    /* Boss Coin Styles */
    .boss-coin {
      position: absolute;
      width: 100px;
      height: 100px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      cursor: pointer;
      z-index: 1000;
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
      padding: 0;
      margin: 0;
    }

    .boss-coin.hidden {
      display: none;
    }

    .boss-coin.active {
      display: block;
    }

    .boss-coin.cracking {
      animation: bossCrack 0.5s forwards;
    }

    @keyframes bossCrack {
      0% {
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
      }

      50% {
        transform: translate(-50%, -50%) scale(1.2) rotate(15deg);
      }

      100% {
        transform: translate(-50%, -50%) scale(1) rotate(-15deg);
      }
    }

    .boss-piece {
      position: absolute;
      width: 50px;
      height: 50px;
      background-color: #FFD700;
      border: 2px solid #DAA520;
      border-radius: 50%;
      animation: bossBreak 1s forwards;
    }

    @keyframes bossBreak {
      0% {
        opacity: 1;
        transform: scale(1);
      }

      100% {
        opacity: 0;
        transform: scale(0.5) rotate(360deg);
      }
    }

    /* Reward Message Styles */
    .reward-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 0.95);
      padding: 20px 40px;
      border-radius: 10px;
      font-size: 24px;
      color: #2c3e50;
      opacity: 0;
      transition: opacity 1.5s ease-out, transform 1.5s ease-out;
      z-index: 25;
    }

    .reward-message.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .reward-message.hidden {
      opacity: 0;
      transform: translate(-50%, -60%) scale(0.8);
    }

    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .modal.show {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background-color: #fff;
      padding: 30px 40px;
      border-radius: 10px;
      text-align: center;
      position: relative;
      max-width: 80%;
    }

    .close-button {
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 28px;
      font-weight: bold;
      color: #333;
      cursor: pointer;
      transition: color 0.2s ease;
    }

    .close-button:hover {
      color: #e74c3c;
    }

    #reward-text {
      font-size: 24px;
      color: #2c3e50;
    }

    /* –û–≤–µ—Ä–ª–µ–π –¥–ª—è –∏–≥—Ä—ã –ø–∞—Ä–∫—É—Ä */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .hidden {
      display: none;
    }

    #parkour-game {
      position: relative;
      width: 800px;
      height: 600px;
      background-color: #333;
      border: 5px solid #fff;
      border-radius: 10px;
    }

    #close-parkour {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 10px 20px;
      background-color: #e74c3c;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      z-index: 2100;
    }

    #close-parkour:hover {
      background-color: #c0392b;
    }
  </style>
</head>

<body>
  <div id="game-area">
    <div id="score">üí∞ –ú–æ–Ω–µ—Ç—ã: 1</div>
    <button id="menu-button">üõ†Ô∏è –ú–µ–Ω—é</button>
    <button id="mini-game-button">üéÆ –ü–∞—Ä–∫—É—Ä</button>
    <div id="upgrades-menu"></div>
    <div id="boss-coin" class="boss-coin hidden">
      <svg viewBox="0 0 100 100" width="100" height="100">
        <circle cx="50" cy="50" r="48" fill="#FFD700" stroke="#DAA520" stroke-width="4" />
        <text x="50" y="60" font-size="30" text-anchor="middle" fill="#DAA520">üí∞</text>
      </svg>
    </div>
    <div id="reward-message" class="reward-message hidden">–ù–∞–≥—Ä–∞–¥–∞: 0 –º–æ–Ω–µ—Ç!</div>
    <div id="reward-modal" class="modal hidden">
      <div class="modal-content">
        <span id="close-reward-modal" class="close-button">&times;</span>
        <p id="reward-text">–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø–æ–ª—É—á–∏–ª–∏ 50 –º–æ–Ω–µ—Ç!</p>
      </div>
    </div>
    <div id="parkour-overlay" class="overlay hidden">
      <div id="parkour-game">
        <canvas id="parkour-canvas" width="800" height="600"></canvas>
        <button id="close-parkour">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
  </div>

  <script>
    let score = 1;
    let maxCoins = 1;
    let coinSpeed = 4000;
    let coinValue = 1;
    let autoClickerInterval = null;
    let autoClickerPower = 0;
    let coinSpawnRate = 2000; // Fixed at 2000ms
    let coinSpawnInterval = setInterval(() => {
      createCoin();
    }, coinSpawnRate);
    let lastClickTime = 0;
    let multiCoinChance = 0;
    let multiCoinCount = 1;

    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –¥–ª—è –±–æ—Å—Å–∞
    let bossInterval = setInterval(spawnBoss, 60000); // –ü–æ—è–≤–ª–µ–Ω–∏–µ –±–æ—Å—Å–∞ –∫–∞–∂–¥—É—é 60 —Å–µ–∫—É–Ω–¥
    let bossActive = false;
    let bossClickCount = 0;
    let bossClickDelay = false;
    let accumulatedBossCoins = 0; // –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –±–æ—Å—Å–∞

    // –û–±—ä—è–≤–ª–µ–Ω–∏–µ parkourCooldown —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
    let parkourCooldown = false;
    let parkourTimer = null;
    let parkourEndTime = null;

    const upgrades = [
      {
        section: "–ú–æ–Ω–µ—Ç—ã üí∞",
        items: [
          {
            name: "–¶–µ–Ω–Ω—ã–µ –º–æ–Ω–µ—Ç—ã üíé",
            description: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –∫–∞–∂–¥–æ–π –º–æ–Ω–µ—Ç—ã –Ω–∞ 1",
            cost: 25,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              coinValue += 1;
            }
          },
          {
            name: "–ú—É–ª—å—Ç–∏–º–æ–Ω–µ—Ç—ã üé≤",
            description: "10% —à–∞–Ω—Å –ø–æ—è–≤–ª–µ–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–æ–Ω–µ—Ç —Å—Ä–∞–∑—É",
            cost: 100,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              multiCoinChance = Math.min(1, multiCoinChance + 0.1);
              multiCoinCount = Math.min(5, multiCoinCount + 1);
            }
          },
          {
            name: "–ó–æ–ª–æ—Ç–∞—è –ª–∏—Ö–æ—Ä–∞–¥–∫–∞ üåü",
            description: "–û–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ. –£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –≤—Å–µ—Ö –º–æ–Ω–µ—Ç –Ω–∞ 50%",
            cost: 250,
            maxLevel: 1,
            currentLevel: 0,
            effect: () => {
              coinValue = Math.ceil(coinValue * 1.5);
            }
          },
          {
            name: "–£–≤–µ–ª–∏—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–æ–Ω–µ—Ç üåü",
            description: "–ü–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã–ø—É—Å–∫–∞—Ç—å –±–æ–ª—å—à–µ –º–æ–Ω–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.",
            cost: 150,
            maxLevel: 3,
            currentLevel: 0,
            effect: () => {
              maxCoins = 1 + upgrades[0].items[3].currentLevel;
            }
          }
        ]
      },
      {
        section: "–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è ü§ñ",
        items: [
          {
            name: "–ê–≤—Ç–æ–∫–ª–∏–∫–µ—Ä",
            description: "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç 1 –º–æ–Ω–µ—Ç—É –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥",
            cost: 50,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              clearInterval(autoClickerInterval);
              autoClickerPower += 1;
              autoClickerInterval = setInterval(() => {
                addCoins(autoClickerPower);
              }, 10000);
            }
          }
        ]
      },
      {
        section: "–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ üéâ",
        items: [
          {
            name: "–ú–æ–Ω–µ—Ç–Ω—ã–π –¥–æ–∂–¥—å üåà",
            description: "–û–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ. –í—ã–∑—ã–≤–∞–µ—Ç –¥–æ–∂–¥—å –∏–∑ –º–æ–Ω–µ—Ç!",
            cost: 500,
            maxLevel: 1,
            currentLevel: 0,
            effect: () => {
              for (let i = 0; i < 20; i++) {
                setTimeout(() => createCoin(true), i * 200);
              }
            }
          }
        ]
      },
      {
        section: "–ë–æ–Ω—É—Å—ã üéÅ",
        items: [
          {
            name: "–£—Å–∫–æ—Ä–µ–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è –º–æ–Ω–µ—Ç ‚è©",
            description: "–£–º–µ–Ω—å—à–∞–µ—Ç –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ—è–≤–ª–µ–Ω–∏—è –º–æ–Ω–µ—Ç –Ω–∞ 10%",
            cost: 125,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              coinSpawnRate = 2000;
              clearInterval(coinSpawnInterval);
              coinSpawnInterval = setInterval(() => {
                createCoin();
              }, coinSpawnRate);
            }
          },
          {
            name: "–ë–æ–Ω—É—Å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –º–æ–Ω–µ—Ç üí∞üí∞",
            description: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –º–æ–Ω–µ—Ç –Ω–∞ 5% —É–º–Ω–æ–∂–∏—Ç–µ–ª—å–Ω–æ",
            cost: 200,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              coinValue = Math.ceil(coinValue * 1.05);
            }
          },
          {
            name: "–î–≤–æ–π–Ω–æ–π –ö–ª–∏–∫–µ—Ä ‚úåÔ∏è",
            description: "–ö–∞–∂–¥—ã–π –∫–ª–∏–∫ –Ω–∞ –º–æ–Ω–µ—Ç—É –¥–∞–µ—Ç –≤ 2 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ –º–æ–Ω–µ—Ç",
            cost: 300,
            maxLevel: 3,
            currentLevel: 0,
            effect: () => {
              coinValue *= 2;
            }
          }
        ]
      }
    ];

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
    }

    function updateScore() {
      document.getElementById('score').textContent = `üí∞ –ú–æ–Ω–µ—Ç—ã: ${score}`;
    }

    function addCoins(amount) {
      score += amount;
      updateScore();
      saveGame();
    }

    function createCoin(isRainCoin = false) {
      if (document.querySelectorAll('.coin').length >= maxCoins) return;

      const coinCount = isRainCoin ? 1 : (Math.random() < multiCoinChance ? multiCoinCount : 1);

      for (let i = 0; i < coinCount; i++) {
        const coin = document.createElement('div');
        coin.className = 'coin';
        coin.setAttribute('data-clicked', 'false');

        const side = Math.random() < 0.5 ? 'left' : 'right';
        if (side === 'left') {
          coin.style.left = '-50px';
          coin.style.top = `${Math.random() * window.innerHeight}px`;
        } else {
          coin.style.left = `${window.innerWidth}px`;
          coin.style.top = `${Math.random() * window.innerHeight}px`;
        }

        const coinSVG = `
      <svg viewBox="0 0 50 50" width="50" height="50">
        <circle cx="25" cy="25" r="23" fill="#FFD700" stroke="#DAA520" stroke-width="2"/>
        <text x="25" y="30" font-size="20" text-anchor="middle" fill="#DAA520">$</text>
      </svg>
    `;

        coin.innerHTML = coinSVG;
        document.getElementById('game-area').appendChild(coin);

        const targetX = Math.random() * window.innerWidth;
        const targetY = Math.random() * window.innerHeight;
        const animationDuration = coinSpeed;

        let startTime = null;
        function animate(currentTime) {
          if (!startTime) startTime = currentTime;
          const elapsed = currentTime - startTime;
          const progress = elapsed / animationDuration;

          if (progress < 1) {
            const x = parseFloat(coin.style.left) + (targetX - parseFloat(coin.style.left)) * progress;
            const y = parseFloat(coin.style.top) + (targetY - parseFloat(coin.style.top)) * progress;
            coin.style.transform = `translate(${x - parseFloat(coin.style.left)}px, ${y - parseFloat(coin.style.top)}px)`;
            requestAnimationFrame(animate);
          } else {
            coin.remove();
            if (!isRainCoin) setTimeout(createCoin, coinSpawnRate);
          }
        }

        requestAnimationFrame(animate);

        coin.addEventListener('mousedown', (e) => {
          if (coin.getAttribute('data-clicked') === 'true') return;
          coin.setAttribute('data-clicked', 'true');

          const currentTime = new Date().getTime();
          if (currentTime - lastClickTime > 50) {
            lastClickTime = currentTime;
            addCoins(coinValue);
            coin.style.transition = 'transform 0.3s, opacity 0.3s';
            coin.style.transform += ' scale(1.5)';
            coin.style.opacity = '0';
            setTimeout(() => {
              coin.remove();
            }, 300);
          }
          e.preventDefault();
        });
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ—è–≤–ª–µ–Ω–∏—è –±–æ—Å—Å–∞
    function spawnBoss() {
      if (bossActive) return;
      bossActive = true;
      const boss = document.getElementById('boss-coin');
      boss.classList.remove('hidden');
      boss.classList.add('active');

      // Remove any existing event listeners to prevent duplicates
      boss.removeEventListener('click', handleBossClick);
      boss.addEventListener('click', handleBossClick);

      // Start the boss fight timer
      setTimeout(endBossFight, 10000);
    }

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–æ–≤ –ø–æ –±–æ—Å—Å—É
    function handleBossClick(e) {
      const boss = document.getElementById('boss-coin');
      // Check if the clicked target is the boss or a child of the boss
      if (!boss.contains(e.target)) return;

      if (bossClickDelay) return; // Prevent click if in cooldown

      bossClickDelay = true; // Set cooldown
      bossClickCount++;
      accumulatedBossCoins += 1; // –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç –∑–∞ –∫–∞–∂–¥—ã–π –∫–ª–∏–∫

      boss.classList.add('cracking');

      // –°–æ–∑–¥–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –º–æ–Ω–µ—Ç—ã
      createBossClickAnimation(e.clientX, e.clientY);

      // –£–¥–∞–ª—è–µ–º –∫–ª–∞—Å—Å –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
      setTimeout(() => {
        boss.classList.remove('cracking');
        bossClickDelay = false; // Reset cooldown
      }, 2000); // 2-second cooldown

      e.preventDefault();
    }

    // –§—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –±–æ—è —Å –±–æ—Å—Å–æ–º
    function endBossFight() {
      const boss = document.getElementById('boss-coin');
      boss.classList.remove('active');
      boss.classList.add('hidden'); // Hide the boss after the fight

      // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞–∑–ª–µ—Ç–∞—é—â–∏—Ö—Å—è –∫—É—Å–∫–æ–≤
      createBossBreakAnimation();

      bossActive = false;

      // –í—ã—á–∏—Å–ª—è–µ–º –Ω–∞–≥—Ä–∞–¥—É –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö –º–æ–Ω–µ—Ç
      const reward = accumulatedBossCoins * 2;
      addCoins(reward);
      accumulatedBossCoins = 0; // –°–±—Ä–æ—Å –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö –º–æ–Ω–µ—Ç

      // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞–≥—Ä–∞–¥–µ
      showRewardModal(reward); // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ showRewardModal
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ –º–æ–Ω–µ—Ç—ã –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –±–æ—Å—Å–∞
    function createBossClickAnimation(x, y) {
      const coin = document.createElement('div');
      coin.className = 'boss-click-coin animate-click';
      coin.style.left = `${x}px`;
      coin.style.top = `${y}px`;
      document.body.appendChild(coin);

      // –£–¥–∞–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
      setTimeout(() => {
        coin.remove();
      }, 1000);
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Ä–∞–∑–ª–µ—Ç–∞—é—â–∏—Ö—Å—è –∫—É—Å–∫–æ–≤ –±–æ—Å—Å–∞
    function createBossBreakAnimation() {
      const boss = document.getElementById('boss-coin'); // Define the boss variable
      const bossArea = document.getElementById('game-area');
      const bossRect = boss.getBoundingClientRect();

      for (let i = 0; i < 10; i++) {
        const piece = document.createElement('div');
        piece.className = 'boss-piece';
        piece.style.left = `${bossRect.left + bossRect.width / 2 - 25}px`;
        piece.style.top = `${bossRect.top + bossRect.height / 2 - 25}px`;
        bossArea.appendChild(piece);

        // –°–ª—É—á–∞–π–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
        const angle = Math.random() * 360;
        const distance = Math.random() * 300 + 100; // 100px –¥–æ 400px
        piece.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
        piece.style.transition = `transform 1s ease-out, opacity 1s ease-out`;
        setTimeout(() => {
          piece.style.transform = `translate(${Math.cos(angle * Math.PI / 180) * distance}px, ${Math.sin(angle * Math.PI / 180) * distance}px) rotate(${angle + 360}deg)`;
          piece.style.opacity = '0';
        }, 10);

        // –£–¥–∞–ª—è–µ–º –∫—É—Å–æ–∫ –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
        setTimeout(() => {
          piece.remove();
        }, 1010);
      }
    }

    function updateUpgradesMenu() {
      const menu = document.getElementById('upgrades-menu');
      menu.innerHTML = '';

      upgrades.forEach((section, sectionIndex) => {
        const sectionElement = document.createElement('div');
        sectionElement.className = 'upgrade-section';
        sectionElement.innerHTML = `<h2>${section.section} üéØ</h2>`;

        section.items.forEach((upgrade, index) => {
          const upgradeElement = document.createElement('div');
          upgradeElement.className = 'upgrade-item';
          upgradeElement.innerHTML = `
        <h3>${upgrade.name}</h3>
        <p>${upgrade.description}</p>
        <p>–°—Ç–æ–∏–º–æ—Å—Ç—å: ${upgrade.cost}</p>
        <p>–£—Ä–æ–≤–µ–Ω—å: ${upgrade.currentLevel}/${upgrade.maxLevel}</p>
        <button onclick="buyUpgrade('${section.section}', ${index})" ${(score < upgrade.cost || upgrade.currentLevel >= upgrade.maxLevel) ? 'disabled' : ''}>–ö—É–ø–∏—Ç—å</button>
      `;
          sectionElement.appendChild(upgradeElement);
        });

        menu.appendChild(sectionElement);
      });
    }

    function createConfetti() {
      const confettiCount = 100;
      const colors = ['#f0f', '#0ff', '#ff0', '#0f0', '#00f'];

      for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * window.innerWidth + 'px';
        confetti.style.top = '-10px';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animation = `confetti ${Math.random() * 3 + 2}s linear`;
        document.body.appendChild(confetti);

        setTimeout(() => confetti.remove(), 5000);
      }
    }

    function buyUpgrade(sectionName, index) {
      const section = upgrades.find(s => s.section === sectionName);
      const upgrade = section.items[index];
      if (score >= upgrade.cost && upgrade.currentLevel < upgrade.maxLevel) {
        score -= upgrade.cost;
        upgrade.currentLevel++;
        upgrade.effect();
        upgrade.cost = Math.floor(upgrade.cost * 1.3);
        updateScore();
        updateUpgradesMenu();
        createConfetti();
        saveGame();
      }
    }

    function saveGame() {
      const gameData = {
        score,
        maxCoins,
        coinSpeed,
        coinValue,
        autoClickerPower,
        coinSpawnRate,
        multiCoinChance,
        multiCoinCount,
        upgrades
      };
      localStorage.setItem('clickerGameSave', JSON.stringify(gameData));
    }

    function loadGame() {
      const savedData = localStorage.getItem('clickerGameSave');
      if (savedData) {
        const gameData = JSON.parse(savedData);
        score = gameData.score || 1;
        maxCoins = gameData.maxCoins || 1;
        coinSpeed = gameData.coinSpeed || 4000;
        coinValue = gameData.coinValue || 1;
        autoClickerPower = gameData.autoClickerPower || 0;
        coinSpawnRate = gameData.coinSpawnRate || 2000;
        multiCoinChance = gameData.multiCoinChance || 0;
        multiCoinCount = gameData.multiCoinCount || 1;

        if (gameData.upgrades && Array.isArray(gameData.upgrades)) {
          upgrades.forEach((section, sectionIndex) => {
            const savedSection = gameData.upgrades[sectionIndex];
            if (savedSection && Array.isArray(savedSection.items)) {
              section.items.forEach((upgrade, itemIndex) => {
                const savedUpgrade = savedSection.items[itemIndex];
                if (savedUpgrade) {
                  upgrade.currentLevel = savedUpgrade.currentLevel || 0;
                  upgrade.cost = savedUpgrade.cost || upgrade.cost;
                } else {
                  console.warn(`Missing upgrade data for section ${sectionIndex}, item ${itemIndex}. Using default values.`);
                }
              });
            } else {
              console.warn(`Missing section data for section ${sectionIndex}. Skipping upgrades in this section.`);
            }
          });
        }

        updateScore();
        updateUpgradesMenu();
      }
    }

    // Function to display the reward modal
    function showRewardModal(reward) {
      const modal = document.getElementById('reward-modal');
      const rewardText = document.getElementById('reward-text');
      rewardText.textContent = `–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø–æ–ª—É—á–∏–ª–∏ ${reward} –º–æ–Ω–µ—Ç!`;
      modal.classList.add('show');

      // Automatically hide the modal after 3 seconds
      setTimeout(() => {
        hideRewardModal();
      }, 3000);
    }

    // Function to hide the reward modal
    function hideRewardModal() {
      const modal = document.getElementById('reward-modal');
      modal.classList.remove('show');
    }

    // Update the endParkourGame function to use the modal
    function endParkourGame(success) {
      if (success) {
        const reward = 2; // –ù–∞–≥—Ä–∞–¥–∞ –≤ –º–æ–Ω–µ—Ç–∞—Ö
        addCoins(reward);
        showRewardModal(reward);
      } else {
        alert('–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.');
      }
      document.getElementById('parkour-overlay').classList.add('hidden');
      startCooldown();
    }

    // Event listener for closing the reward modal
    document.getElementById('close-reward-modal').addEventListener('click', hideRewardModal);

    // Function to start cooldown and save end time
    function startCooldown() {
      parkourCooldown = true;
      const button = document.getElementById('mini-game-button');
      button.disabled = true;
      const cooldownDuration = 300; // 5 minutes in seconds
      parkourEndTime = Date.now() + cooldownDuration * 1000;
      localStorage.setItem('parkourEndTime', parkourEndTime);

      updateCooldownButton();

      parkourTimer = setInterval(() => {
        updateCooldownButton();
      }, 1000);
    }

    // Function to update the cooldown button based on remaining time
    function updateCooldownButton() {
      const button = document.getElementById('mini-game-button');
      const remainingTime = Math.max(0, Math.floor((parkourEndTime - Date.now()) / 1000));

      if (remainingTime > 0) {
        button.textContent = `üéÆ –ü–∞—Ä–∫—É—Ä (${formatTime(remainingTime)})`;
      } else {
        clearInterval(parkourTimer);
        parkourCooldown = false;
        button.disabled = false;
        button.textContent = 'üéÆ –ü–∞—Ä–∫—É—Ä';
        localStorage.removeItem('parkourEndTime');
      }
    }

    // Modify openParkourGame to handle existing cooldown
    function openParkourGame() {
      if (parkourCooldown) return;
      document.getElementById('parkour-overlay').classList.remove('hidden');
      initializeParkourGame();
    }

    // Load the cooldown state on page load
    function loadCooldown() {
      const savedEndTime = localStorage.getItem('parkourEndTime');
      if (savedEndTime) {
        parkourEndTime = parseInt(savedEndTime, 10);
        const remainingTime = Math.floor((parkourEndTime - Date.now()) / 1000);
        if (remainingTime > 0) {
          parkourCooldown = true;
          const button = document.getElementById('mini-game-button');
          button.disabled = true;
          updateCooldownButton();
          parkourTimer = setInterval(() => {
            updateCooldownButton();
          }, 1000);
        } else {
          localStorage.removeItem('parkourEndTime');
        }
      }
    }

    // Consolidate window.onload to call both loadGame and loadCooldown
    window.onload = () => {
      loadGame();
      loadCooldown();
      updateScore();
      updateUpgradesMenu();
      createCoin();
    };

    // Other event listeners
    document.getElementById('menu-button').addEventListener('click', () => {
      const menu = document.getElementById('upgrades-menu');
      menu.style.display = (menu.style.display === 'block') ? 'none' : 'block';
    });

    document.getElementById('mini-game-button').addEventListener('click', openParkourGame);

    document.getElementById('close-parkour').addEventListener('click', () => {
      document.getElementById('parkour-overlay').classList.add('hidden');
    });

    // Game loop for the parkour game
    function initializeParkourGame() {
      const canvas = document.getElementById('parkour-canvas');
      const ctx = canvas.getContext('2d');

      // –ò–≥—Ä–æ–∫
      const player = {
        x: 50,
        y: 500,
        width: 50,
        height: 50,
        color: '#2ecc71',
        velX: 0,
        velY: 0,
        speed: 5,
        jumping: false,
        gravity: 0.5,
        jumpStrength: 12
      };

      // –ü–ª–∞—Ç—Ñ–æ—Ä–º—ã
      const platforms = [
        { x: 0, y: 550, width: 800, height: 50 },
        { x: 150, y: 450, width: 100, height: 20 },
        { x: 300, y: 350, width: 100, height: 20 },
        { x: 450, y: 250, width: 100, height: 20 },
        { x: 600, y: 150, width: 100, height: 20 }
      ];

      // –¶–µ–ª—å
      const goal = { x: 750, y: 100, width: 50, height: 50 };

      // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
      const keys = {};

      document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
      });

      document.addEventListener('keyup', (e) => {
        keys[e.code] = false;
      });

      function update() {
        // –î–≤–∏–∂–µ–Ω–∏–µ
        if (keys['ArrowRight']) {
          player.velX = player.speed;
        } else if (keys['ArrowLeft']) {
          player.velX = -player.speed;
        } else {
          player.velX = 0;
        }

        if (keys['Space'] || keys['ArrowUp']) {
          if (!player.jumping) {
            player.velY = -player.jumpStrength;
            player.jumping = true;
          }
        }

        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏
        player.velY += player.gravity;
        player.x += player.velX;
        player.y += player.velY;

        // –ì—Ä–∞–Ω–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
        if (player.y + player.height > canvas.height) {
          player.y = canvas.height - player.height;
          player.velY = 0;
          player.jumping = false;
        }

        if (player.x < 0) player.x = 0;
        if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º–∏
        platforms.forEach(platform => {
          if (
            player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y + player.height > platform.y &&
            player.y + player.height < platform.y + platform.height
          ) {
            player.y = platform.y - player.height;
            player.velY = 0;
            player.jumping = false;
          }
        });

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ü–µ–ª–∏
        if (
          player.x < goal.x + goal.width &&
          player.x + player.width > goal.x &&
          player.y < goal.y + goal.height &&
          player.y + player.height > goal.y
        ) {
          endParkourGame(true);
        }

        render();
        requestAnimationFrame(update);
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // –†–∏—Å–æ–≤–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.width, player.height);

        // –†–∏—Å–æ–≤–∞–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º
        ctx.fillStyle = '#95a5a6';
        platforms.forEach(platform => {
          ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        });

        // –†–∏—Å–æ–≤–∞–Ω–∏–µ —Ü–µ–ª–∏
        ctx.fillStyle = '#e74c3c';
        ctx.fillRect(goal.x, goal.y, goal.width, goal.height);
      }

      update();
    }

    window.addEventListener('beforeunload', saveGame);
    document.getElementById('menu-button').addEventListener('click', saveGame);
    document.getElementById('upgrades-menu').addEventListener('click', saveGame);
  </script>
</body>

</html>
