<html>

<head>
  <base href="https://clickergame.example.com/v5">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>—Ä–µ–≤–æ—Ä–∫ —Å–º–∞—á–Ω–æ–≥–æ –∫–ª–∏–∫–µ—Ä–∞</title>
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background-color: #f0f0f0;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #game-area {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    }

    .coin {
      position: absolute;
      width: 50px;
      height: 50px;
      cursor: pointer;
      transition: transform 0.3s ease-out;
      z-index: 1;
    }

    .coin:hover {
      transform: scale(1.1);
    }

    #score {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 28px;
      font-weight: bold;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px 20px;
      border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      color: #2c3e50;
    }

    #menu-button {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 24px;
      padding: 12px 24px;
      background-color: #8e44ad;
      background-image: linear-gradient(45deg, #8e44ad, #3498db);
      color: white;
      border: none;
      cursor: pointer;
      z-index: 10;
      border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }

    #menu-button:hover {
      background-image: linear-gradient(45deg, #7f3fbf, #2980b9);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    #upgrades-menu {
      display: none;
      position: absolute;
      top: 80px;
      left: 20px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 25px;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      max-width: 350px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 5;
      transition: all 0.3s ease;
    }

    .upgrade-section {
      margin-bottom: 25px;
      border-bottom: 2px solid #e0e0e0;
      padding-bottom: 15px;
    }

    .upgrade-section h2 {
      margin-top: 0;
      color: #2c3e50;
      font-size: 24px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .upgrade-item {
      margin-bottom: 20px;
      padding: 20px;
      background-color: #f9f9f9;
      border-radius: 15px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      z-index: 15;
    }

    .upgrade-item:hover {
      background-color: #f0f0f0;
      transform: translateY(-3px);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
    }

    .upgrade-item h3 {
      margin-top: 0;
      color: #34495e;
      font-size: 20px;
    }

    .upgrade-item p {
      font-size: 16px;
      margin-bottom: 10px;
      color: #7f8c8d;
    }

    .upgrade-item button {
      background-color: #2ecc71;
      color: white;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 16px;
      border-radius: 25px;
      transition: all 0.3s ease;
      width: 100%;
    }

    .upgrade-item button:hover {
      background-color: #27ae60;
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    }

    .upgrade-item button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    @keyframes confetti {
      0% {
        transform: translateY(0) rotate(0deg);
        opacity: 1;
      }

      100% {
        transform: translateY(1000px) rotate(720deg);
        opacity: 0;
      }
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #f0f;
      opacity: 0;
      pointer-events: none;
    }

    /* Boss Coin Styles */
    .boss-coin {
      position: absolute;
      width: 100px;
      height: 100px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      cursor: pointer;
      z-index: 1000;
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
      padding: 0;
      margin: 0;
    }

    .boss-coin.hidden {
      display: none;
    }

    .boss-coin.active {
      display: block;
    }

    .boss-coin.cracking {
      animation: bossCrack 0.5s forwards;
    }

    @keyframes bossCrack {
      0% {
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
      }

      50% {
        transform: translate(-50%, -50%) scale(1.2) rotate(15deg);
      }

      100% {
        transform: translate(-50%, -50%) scale(1) rotate(-15deg);
      }
    }

    .boss-piece {
      position: absolute;
      width: 50px;
      height: 50px;
      background-color: #FFD700;
      border: 2px solid #DAA520;
      border-radius: 50%;
      animation: bossBreak 1s forwards;
    }

    @keyframes bossBreak {
      0% {
        opacity: 1;
        transform: scale(1);
      }

      100% {
        opacity: 0;
        transform: scale(0.5) rotate(360deg);
      }
    }

    /* Reward Message Styles */
    .reward-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 0.95);
      padding: 20px 40px;
      border-radius: 10px;
      font-size: 24px;
      color: #2c3e50;
      opacity: 0;
      transition: opacity 1.5s ease-out, transform 1.5s ease-out;
      z-index: 25;
    }

    .reward-message.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .reward-message.hidden {
      opacity: 0;
      transform: translate(-50%, -60%) scale(0.8);
    }

    /* –ê–Ω–∏–º–∞—Ü–∏—è –º–æ–Ω–µ—Ç—ã –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –±–æ—Å—Å–∞ */
    .boss-click-coin {
      position: absolute;
      width: 30px;
      height: 30px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><circle cx="25" cy="25" r="23" fill="%23FFD700" stroke="%23DAA520" stroke-width="2"/><text x="25" y="30" font-size="20" text-anchor="middle" fill="%23DAA520">$</text></svg>');
      background-size: cover;
      pointer-events: none;
      animation: clickCoin 1s forwards;
    }

    @keyframes clickCoin {
      0% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }

      100% {
        transform: translate(-50%, -150%) scale(1.5);
        opacity: 0;
      }
    }

    .animate-click {
      animation: clickEffect 1s forwards;
    }

    @keyframes clickEffect {
      0% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }

      100% {
        transform: translate(-50%, -150%) scale(1.5);
        opacity: 0;
      }
    }
  </style>
</head>

<body>
  <div id="game-area">
    <div id="score">üí∞ –ú–æ–Ω–µ—Ç—ã: 1</div>
    <button id="menu-button">üõ†Ô∏è –ú–µ–Ω—é</button>
    <div id="upgrades-menu"></div>
    <div id="boss-coin" class="boss-coin hidden">
      <svg viewBox="0 0 100 100" width="100" height="100">
        <circle cx="50" cy="50" r="48" fill="#FFD700" stroke="#DAA520" stroke-width="4" />
        <text x="50" y="60" font-size="30" text-anchor="middle" fill="#DAA520">üí∞</text>
      </svg>
    </div>
    <div id="reward-message" class="reward-message hidden">–ù–∞–≥—Ä–∞–¥–∞: 0 –º–æ–Ω–µ—Ç!</div>
  </div>

  <script>
    let score = 1;
    let maxCoins = 1;
    let coinSpeed = 4000;
    let coinValue = 1;
    let autoClickerInterval = null;
    let autoClickerPower = 0;
    let coinSpawnRate = 2000; // Fixed at 2000ms
    let coinSpawnInterval = setInterval(() => {
      createCoin();
    }, coinSpawnRate);
    let lastClickTime = 0;
    let multiCoinChance = 0;
    let multiCoinCount = 1;

    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –¥–ª—è –±–æ—Å—Å–∞
    let bossInterval = setInterval(spawnBoss, 60000); // –ü–æ—è–≤–ª–µ–Ω–∏–µ –±–æ—Å—Å–∞ –∫–∞–∂–¥—ã–µ 60 —Å–µ–∫—É–Ω–¥
    let bossActive = false;
    let bossClickCount = 0;
    let bossClickDelay = false;
    let accumulatedBossCoins = 0; // –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –±–æ—Å—Å–∞

    const upgrades = [
      {
        section: "–ú–æ–Ω–µ—Ç—ã üí∞",
        items: [
          {
            name: "–¶–µ–Ω–Ω—ã–µ –º–æ–Ω–µ—Ç—ã üíé",
            description: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –∫–∞–∂–¥–æ–π –º–æ–Ω–µ—Ç—ã –Ω–∞ 1",
            cost: 25,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              coinValue += 1;
            }
          },
          {
            name: "–ú—É–ª—å—Ç–∏–º–æ–Ω–µ—Ç—ã üé≤",
            description: "10% —à–∞–Ω—Å –ø–æ—è–≤–ª–µ–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–æ–Ω–µ—Ç —Å—Ä–∞–∑—É",
            cost: 100,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              multiCoinChance = Math.min(1, multiCoinChance + 0.1);
              multiCoinCount = Math.min(5, multiCoinCount + 1);
            }
          },
          {
            name: "–ó–æ–ª–æ—Ç–∞—è –ª–∏—Ö–æ—Ä–∞–¥–∫–∞ üåü",
            description: "–û–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ. –£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –≤—Å–µ—Ö –º–æ–Ω–µ—Ç –Ω–∞ 50%",
            cost: 250,
            maxLevel: 1,
            currentLevel: 0,
            effect: () => {
              coinValue = Math.ceil(coinValue * 1.5);
            }
          },
          {
            name: "–£–≤–µ–ª–∏—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–æ–Ω–µ—Ç üåü",
            description: "–ü–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã–ø—É—Å–∫–∞—Ç—å –±–æ–ª—å—à–µ –º–æ–Ω–µ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.",
            cost: 150,
            maxLevel: 3,
            currentLevel: 0,
            effect: () => {
              maxCoins = 1 + upgrades[0].items[3].currentLevel;
            }
          }
        ]
      },
      {
        section: "–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è ü§ñ",
        items: [
          {
            name: "–ê–≤—Ç–æ–∫–ª–∏–∫–µ—Ä",
            description: "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç 1 –º–æ–Ω–µ—Ç—É –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥",
            cost: 50,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              clearInterval(autoClickerInterval);
              autoClickerPower += 1;
              autoClickerInterval = setInterval(() => {
                addCoins(autoClickerPower);
              }, 10000);
            }
          }
        ]
      },
      {
        section: "–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ üéâ",
        items: [
          {
            name: "–ú–æ–Ω–µ—Ç–Ω—ã–π –¥–æ–∂–¥—å üåà",
            description: "–û–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–µ —É–ª—É—á—à–µ–Ω–∏–µ. –í—ã–∑—ã–≤–∞–µ—Ç –¥–æ–∂–¥—å –∏–∑ –º–æ–Ω–µ—Ç!",
            cost: 500,
            maxLevel: 1,
            currentLevel: 0,
            effect: () => {
              for (let i = 0; i < 20; i++) {
                setTimeout(() => createCoin(true), i * 200);
              }
            }
          }
        ]
      },
      {
        section: "–ë–æ–Ω—É—Å—ã üéÅ",
        items: [
          {
            name: "–£—Å–∫–æ—Ä–µ–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è –º–æ–Ω–µ—Ç ‚è©",
            description: "–£–º–µ–Ω—å—à–∞–µ—Ç –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ—è–≤–ª–µ–Ω–∏—è –º–æ–Ω–µ—Ç –Ω–∞ 10%",
            cost: 125,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              coinSpawnRate = 2000;
              clearInterval(coinSpawnInterval);
              coinSpawnInterval = setInterval(() => {
                createCoin();
              }, coinSpawnRate);
            }
          },
          {
            name: "–ë–æ–Ω—É—Å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –º–æ–Ω–µ—Ç üí∞üí∞",
            description: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –º–æ–Ω–µ—Ç –Ω–∞ 5% —É–º–Ω–æ–∂–∏—Ç–µ–ª—å–Ω–æ",
            cost: 200,
            maxLevel: 5,
            currentLevel: 0,
            effect: () => {
              coinValue = Math.ceil(coinValue * 1.05);
            }
          },
          {
            name: "x2 –º–æ–Ω–µ—Ç—ã ‚úåÔ∏è",
            description: "–ö–∞–∂–¥—ã–π –∫–ª–∏–∫ –Ω–∞ –º–æ–Ω–µ—Ç—É –¥–∞–µ—Ç –≤ 2 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ –º–æ–Ω–µ—Ç",
            cost: 300,
            maxLevel: 3,
            currentLevel: 0,
            effect: () => {
              coinValue *= 2;
            }
          }
        ]
      }
    ];

    function updateScore() {
      document.getElementById('score').textContent = `üí∞ –ú–æ–Ω–µ—Ç—ã: ${score}`;
    }

    function addCoins(amount) {
      score += amount;
      updateScore();
      saveGame();
    }

    function createCoin(isRainCoin = false) {
      if (document.querySelectorAll('.coin').length >= maxCoins) return;

      const coinCount = isRainCoin ? 1 : (Math.random() < multiCoinChance ? multiCoinCount : 1);

      for (let i = 0; i < coinCount; i++) {
        const coin = document.createElement('div');
        coin.className = 'coin';
        coin.setAttribute('data-clicked', 'false');

        const side = Math.random() < 0.5 ? 'left' : 'right';
        if (side === 'left') {
          coin.style.left = '-50px';
          coin.style.top = `${Math.random() * window.innerHeight}px`;
        } else {
          coin.style.left = `${window.innerWidth}px`;
          coin.style.top = `${Math.random() * window.innerHeight}px`;
        }

        const coinSVG = `
      <svg viewBox="0 0 50 50" width="50" height="50">
        <circle cx="25" cy="25" r="23" fill="#FFD700" stroke="#DAA520" stroke-width="2"/>
        <text x="25" y="30" font-size="20" text-anchor="middle" fill="#DAA520">$</text>
      </svg>
    `;

        coin.innerHTML = coinSVG;
        document.getElementById('game-area').appendChild(coin);

        const targetX = Math.random() * window.innerWidth;
        const targetY = Math.random() * window.innerHeight;
        const animationDuration = coinSpeed;

        let startTime = null;
        function animate(currentTime) {
          if (!startTime) startTime = currentTime;
          const elapsed = currentTime - startTime;
          const progress = elapsed / animationDuration;

          if (progress < 1) {
            const x = parseFloat(coin.style.left) + (targetX - parseFloat(coin.style.left)) * progress;
            const y = parseFloat(coin.style.top) + (targetY - parseFloat(coin.style.top)) * progress;
            coin.style.transform = `translate(${x - parseFloat(coin.style.left)}px, ${y - parseFloat(coin.style.top)}px)`;
            requestAnimationFrame(animate);
          } else {
            coin.remove();
            if (!isRainCoin) setTimeout(createCoin, coinSpawnRate);
          }
        }

        requestAnimationFrame(animate);

        coin.addEventListener('mousedown', (e) => {
          if (coin.getAttribute('data-clicked') === 'true') return;
          coin.setAttribute('data-clicked', 'true');

          const currentTime = new Date().getTime();
          if (currentTime - lastClickTime > 50) {
            lastClickTime = currentTime;
            addCoins(coinValue);
            coin.style.transition = 'transform 0.3s, opacity 0.3s';
            coin.style.transform += ' scale(1.5)';
            coin.style.opacity = '0';
            setTimeout(() => {
              coin.remove();
            }, 300);
          }
          e.preventDefault();
        });
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ—è–≤–ª–µ–Ω–∏—è –±–æ—Å—Å–∞
    function spawnBoss() {
      if (bossActive) return;
      bossActive = true;
      const boss = document.getElementById('boss-coin');
      boss.classList.remove('hidden');
      boss.classList.add('active');

      // Remove any existing event listeners to prevent duplicates
      boss.removeEventListener('click', handleBossClick);
      boss.addEventListener('click', handleBossClick);

      // Start the boss fight timer
      setTimeout(endBossFight, 10000);
    }

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–æ–≤ –ø–æ –±–æ—Å—Å—É
    function handleBossClick(e) {
      const boss = document.getElementById('boss-coin');
      // Check if the clicked target is the boss or a child of the boss
      if (!boss.contains(e.target)) return;

      if (bossClickDelay) return; // Prevent click if in cooldown

      bossClickDelay = true; // Set cooldown
      bossClickCount++;
      accumulatedBossCoins += 1; // –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç –∑–∞ –∫–∞–∂–¥—ã–π –∫–ª–∏–∫

      boss.classList.add('cracking');

      // –°–æ–∑–¥–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –º–æ–Ω–µ—Ç—ã
      createBossClickAnimation(e.clientX, e.clientY);

      // –£–¥–∞–ª—è–µ–º –∫–ª–∞—Å—Å –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
      setTimeout(() => {
        boss.classList.remove('cracking');
        bossClickDelay = false; // Reset cooldown
      }, 2000); // 2-second cooldown

      e.preventDefault();
    }

    // –§—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –±–æ—è —Å –±–æ—Å—Å–æ–º
    function endBossFight() {
      const boss = document.getElementById('boss-coin');
      boss.classList.remove('active');
      boss.classList.add('hidden'); // Hide the boss after the fight

      // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞–∑–ª–µ—Ç–∞—é—â–∏—Ö—Å—è –∫—É—Å–∫–æ–≤
      createBossBreakAnimation();

      bossActive = false;

      // –í—ã—á–∏—Å–ª—è–µ–º –Ω–∞–≥—Ä–∞–¥—É –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö –º–æ–Ω–µ—Ç
      const reward = accumulatedBossCoins * 2;
      addCoins(reward);
      accumulatedBossCoins = 0; // –°–±—Ä–æ—Å –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö –º–æ–Ω–µ—Ç

      // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞–≥—Ä–∞–¥–µ
      showRewardMessage(reward);
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ –º–æ–Ω–µ—Ç—ã –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ –±–æ—Å—Å–∞
    function createBossClickAnimation(x, y) {
      const coin = document.createElement('div');
      coin.className = 'boss-click-coin animate-click';
      coin.style.left = `${x}px`;
      coin.style.top = `${y}px`;
      document.body.appendChild(coin);

      // –£–¥–∞–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
      setTimeout(() => {
        coin.remove();
      }, 1000);
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Ä–∞–∑–ª–µ—Ç–∞—é—â–∏—Ö—Å—è –∫—É—Å–∫–æ–≤ –±–æ—Å—Å–∞
    function createBossBreakAnimation() {
      const boss = document.getElementById('boss-coin'); // Define the boss variable
      const bossArea = document.getElementById('game-area');
      const bossRect = boss.getBoundingClientRect();

      for (let i = 0; i < 10; i++) {
        const piece = document.createElement('div');
        piece.className = 'boss-piece';
        piece.style.left = `${bossRect.left + bossRect.width / 2 - 25}px`;
        piece.style.top = `${bossRect.top + bossRect.height / 2 - 25}px`;
        bossArea.appendChild(piece);

        // –°–ª—É—á–∞–π–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
        const angle = Math.random() * 360;
        const distance = Math.random() * 300 + 100; // 100px –¥–æ 400px
        piece.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
        piece.style.transition = `transform 1s ease-out, opacity 1s ease-out`;
        setTimeout(() => {
          piece.style.transform = `translate(${Math.cos(angle * Math.PI / 180) * distance}px, ${Math.sin(angle * Math.PI / 180) * distance}px) rotate(${angle + 360}deg)`;
          piece.style.opacity = '0';
        }, 10);

        // –£–¥–∞–ª—è–µ–º –∫—É—Å–æ–∫ –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
        setTimeout(() => {
          piece.remove();
        }, 1010);
      }
    }

    function updateUpgradesMenu() {
      const menu = document.getElementById('upgrades-menu');
      menu.innerHTML = '';

      upgrades.forEach((section, sectionIndex) => {
        const sectionElement = document.createElement('div');
        sectionElement.className = 'upgrade-section';
        sectionElement.innerHTML = `<h2>${section.section} üéØ</h2>`;

        section.items.forEach((upgrade, index) => {
          const upgradeElement = document.createElement('div');
          upgradeElement.className = 'upgrade-item';
          upgradeElement.innerHTML = `
        <h3>${upgrade.name}</h3>
        <p>${upgrade.description}</p>
        <p>–°—Ç–æ–∏–º–æ—Å—Ç—å: ${upgrade.cost}</p>
        <p>–£—Ä–æ–≤–µ–Ω—å: ${upgrade.currentLevel}/${upgrade.maxLevel}</p>
        <button onclick="buyUpgrade('${section.section}', ${index})" ${(score < upgrade.cost || upgrade.currentLevel >= upgrade.maxLevel) ? 'disabled' : ''}>–ö—É–ø–∏—Ç—å</button>
      `;
          sectionElement.appendChild(upgradeElement);
        });

        menu.appendChild(sectionElement);
      });
    }

    function createConfetti() {
      const confettiCount = 100;
      const colors = ['#f0f', '#0ff', '#ff0', '#0f0', '#00f'];

      for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * window.innerWidth + 'px';
        confetti.style.top = '-10px';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animation = `confetti ${Math.random() * 3 + 2}s linear`;
        document.body.appendChild(confetti);

        setTimeout(() => confetti.remove(), 5000);
      }
    }

    function buyUpgrade(sectionName, index) {
      const section = upgrades.find(s => s.section === sectionName);
      const upgrade = section.items[index];
      if (score >= upgrade.cost && upgrade.currentLevel < upgrade.maxLevel) {
        score -= upgrade.cost;
        upgrade.currentLevel++;
        upgrade.effect();
        upgrade.cost = Math.floor(upgrade.cost * 1.3);
        updateScore();
        updateUpgradesMenu();
        createConfetti();
        saveGame();
      }
    }

    function saveGame() {
      const gameData = {
        score,
        maxCoins,
        coinSpeed,
        coinValue,
        autoClickerPower,
        coinSpawnRate,
        multiCoinChance,
        multiCoinCount,
        upgrades
      };
      localStorage.setItem('clickerGameSave', JSON.stringify(gameData));
    }

    function loadGame() {
      const savedData = localStorage.getItem('clickerGameSave');
      if (savedData) {
        const gameData = JSON.parse(savedData);
        score = gameData.score || 1;
        maxCoins = gameData.maxCoins || 1;
        coinSpeed = gameData.coinSpeed || 4000;
        coinValue = gameData.coinValue || 1;
        autoClickerPower = gameData.autoClickerPower || 0;
        coinSpawnRate = gameData.coinSpawnRate || 2000;
        multiCoinChance = gameData.multiCoinChance || 0;
        multiCoinCount = gameData.multiCoinCount || 1;

        if (gameData.upgrades && Array.isArray(gameData.upgrades)) {
          upgrades.forEach((section, sectionIndex) => {
            const savedSection = gameData.upgrades[sectionIndex];
            if (savedSection && Array.isArray(savedSection.items)) {
              section.items.forEach((upgrade, itemIndex) => {
                const savedUpgrade = savedSection.items[itemIndex];
                if (savedUpgrade) {
                  upgrade.currentLevel = savedUpgrade.currentLevel || 0;
                  upgrade.cost = savedUpgrade.cost || upgrade.cost;
                } else {
                  console.warn(`Missing upgrade data for section ${sectionIndex}, item ${itemIndex}. Using default values.`);
                }
              });
            } else {
              console.warn(`Missing section data for section ${sectionIndex}. Skipping upgrades in this section.`);
            }
          });
        }

        updateScore();
        updateUpgradesMenu();
      }
    }

    function showRewardMessage(reward) {
      const message = document.getElementById('reward-message');
      message.textContent = `–ù–∞–≥—Ä–∞–¥–∞: ${reward} –º–æ–Ω–µ—Ç!`;
      message.classList.add('show');
      message.classList.remove('hidden');

      setTimeout(() => {
        message.classList.remove('show');
      }, 3000);
    }

    window.addEventListener('beforeunload', saveGame);
    document.getElementById('menu-button').addEventListener('click', saveGame);
    document.getElementById('upgrades-menu').addEventListener('click', saveGame);

    document.getElementById('menu-button').addEventListener('click', () => {
      const menu = document.getElementById('upgrades-menu');
      menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
      updateUpgradesMenu();
    });

    window.onload = loadGame;

    updateScore();
    createCoin();
  </script>
</body>

</html>
